// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract SourceCodesAce {
    //Used to update Ace8 and Ace16 games
    string public updateGame =
        'const [qty, cmcIds, geckoIdsString] = args;if(secrets.cmcApiKey===""){throw Error(`ACE${qty}: CMC API key not set`);}const quantity=parseInt(qty),PRECISION=10**8,EPSILON=1e-10,cmcIdArray=cmcIds.split(",").filter(id=>id!=="0"&&id!==""),cmcIdsString=cmcIdArray.join(","),geckoIdArray=geckoIdsString.split(",").filter(id=>id!=="");try{const coinMarketCapRequest=Functions.makeHttpRequest({url:`https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest`,headers:{"X-CMC_PRO_API_KEY":secrets.cmcApiKey},params:{convert:"USD",id:cmcIdsString,},});const cmcResponse=await coinMarketCapRequest;if(!cmcResponse.error&&cmcResponse.data&&cmcResponse.data.data){const data=cmcResponse.data.data,idToSymbol={};for(const key in data){idToSymbol[data[key].id]=key;}let prices=cmcIdArray.map(id=>{const symbol=idToSymbol[id];if(data[symbol]&&data[symbol].quote&&data[symbol].quote.USD){const price=data[symbol].quote.USD.price,scaledPrice=Math.floor((price+EPSILON)*PRECISION);return scaledPrice>0?scaledPrice:1;}return 0;});while(prices.length<quantity){prices.push(0);}return Functions.encodeString(prices.join(","));}const geckoRequest=Functions.makeHttpRequest({url:`https://api.coingecko.com/api/v3/simple/price`,params:{ids:geckoIdArray.join(","),vs_currencies:"usd",...(secrets.geckoApiKey?{x_cg_demo_api_key:secrets.geckoApiKey}:{})}});const geckoResponse=await geckoRequest;if(geckoResponse.data){let prices=geckoIdArray.map(geckoId=>{if(geckoResponse.data[geckoId]&&geckoResponse.data[geckoId].usd){const price=geckoResponse.data[geckoId].usd,scaledPrice=Math.floor((price+EPSILON)*PRECISION);return scaledPrice>0?scaledPrice:1;}return 0;});while(prices.length<quantity){prices.push(0);}return Functions.encodeString(prices.join(","));}throw Error("Both CMC and CoinGecko requests failed");}catch(error){throw error;}';

    //Used to get the top 100 coins
    string public sourceTop100 =
        'if(secrets.cmcApiKey===""||secrets.geckoApiKey===""){throw Error("API keys not set")}let lastIndex=parseInt(args[1])||0;let itLasts=parseInt(args[2])||0;if(itLasts===0){return Functions.encodeUint256(0)}try{const[cmcResponse,geckoResponse1,geckoResponse2]=await Promise.all([Functions.makeHttpRequest({url:`https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest`,headers:{"X-CMC_PRO_API_KEY":secrets.cmcApiKey},params:{start:1,limit:200,sort:"market_cap"}}),Functions.makeHttpRequest({url:`https://api.coingecko.com/api/v3/coins/markets`,params:{vs_currency:"usd",order:"market_cap_desc",page:1,...(secrets.geckoApiKey?{x_cg_demo_api_key:secrets.geckoApiKey}:{})}}),Functions.makeHttpRequest({url:`https://api.coingecko.com/api/v3/coins/markets`,params:{vs_currency:"usd",order:"market_cap_desc",page:2,...(secrets.geckoApiKey?{x_cg_demo_api_key:secrets.geckoApiKey}:{})}})]);if(!cmcResponse||!cmcResponse.data||!cmcResponse.data.data){throw Error("Invalid CMC response")}if(!geckoResponse1||!geckoResponse1.data){throw Error("Invalid Gecko response")}const geckoResponse=geckoResponse1.data.concat(geckoResponse2.data);const geckoCoins=new Map();geckoResponse.forEach((coin)=>{geckoCoins.set(coin.symbol.toLowerCase(),{id:coin.id,name:coin.name.toLowerCase()})});const finalCoins=[];const cmcCoins=cmcResponse.data.data;for(let i=lastIndex;i<cmcCoins.length&&finalCoins.length<7&&itLasts>0;i+=1){const cmcCoin=cmcCoins[i];if((cmcCoin.tags&&cmcCoin.tags.includes("stablecoin"))||cmcCoin.symbol==="FTM"){lastIndex+=1;continue}const geckoCoin=geckoCoins.get(cmcCoin.symbol.toLowerCase());if(geckoCoin&&geckoCoin.name===cmcCoin.name.toLowerCase()){finalCoins.push({cmc_id:cmcCoin.id,gecko_id:geckoCoin.id,symbol:cmcCoin.symbol});itLasts-=1}lastIndex+=1}const returnString=finalCoins.length>0?`${ lastIndex };${finalCoins.map((coin)=>`${coin.cmc_id },${coin.gecko_id },${coin.symbol }`).join(";")}`:"";return Functions.encodeString(returnString)}catch(error){throw error}';

    //Used to prepare the indexes of the top 100 that will be used in the new game
    string public newGame =
        'const size=parseInt(args[1]);if(!size||size<=0){throw Error("Invalid size argument")}try{const numbers=Array.from({length:100},(_,i)=>i);for(let i=numbers.length-1;i>0;i-=1){const j=Math.floor(Math.random()*(i+1));[numbers[i],numbers[j]]=[numbers[j],numbers[i]]}const result=numbers.slice(0,size);return Functions.encodeString(result.join(","))}catch(error){throw error}';
}
